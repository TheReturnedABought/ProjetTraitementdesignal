import easyocr
import cv2
import numpy as np
import matplotlib.pyplot as plt


# =============================
#  Inversion de couleurs avec pr√©servation de la qualit√©
# =============================
def invert_with_quality_preservation(img):
    """
    Inverse les couleurs en pr√©servant la qualit√© des caract√®res.
    Optimis√© pour texte blanc sur fond sombre.
    """
    # 1) Upscale AVANT tout traitement (crucial pour qualit√©)
    img_upscaled = cv2.resize(img, None, fx=5, fy=5, interpolation=cv2.INTER_CUBIC)

    # 2) Conversion en grayscale
    gray = cv2.cvtColor(img_upscaled, cv2.COLOR_BGR2GRAY)

    # 3) D√©bruitage AVANT inversion (pr√©serve les contours)
    gray = cv2.fastNlMeansDenoising(gray, h=8)

    # 4) Normalisation pour maximiser le contraste
    gray = cv2.normalize(gray, None, 0, 255, cv2.NORM_MINMAX)

    # 5) INVERSION propre
    inverted = cv2.bitwise_not(gray)

    # 6) Seuillage adaptatif sur l'image invers√©e (meilleur que binarisation globale)
    # Utilise la m√©thode gaussienne qui est plus douce
    binary = cv2.adaptiveThreshold(
        inverted,
        255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY,
        blockSize=15,  # Taille de la zone locale (doit √™tre impair)
        C=3  # Constante soustraite (ajuster selon besoin)
    )

    # 7) Morphologie pour nettoyer et renforcer les caract√®res
    # Erosion l√©g√®re pour enlever le bruit
    kernel_erode = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2, 2))
    binary = cv2.morphologyEx(binary, cv2.MORPH_ERODE, kernel_erode, iterations=1)

    # Dilatation pour r√©cup√©rer l'√©paisseur des lettres
    kernel_dilate = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2, 2))
    binary = cv2.morphologyEx(binary, cv2.MORPH_DILATE, kernel_dilate, iterations=1)

    return binary, inverted


# =============================
#  Alternative: Extraction directe du texte (sans inversion compl√®te)
# =============================
def extract_text_channel(img):
    """
    Extrait le canal de luminance du texte blanc.
    Alternative √† l'inversion qui peut donner de meilleurs r√©sultats.
    """
    # Upscale
    img_upscaled = cv2.resize(img, None, fx=5, fy=5, interpolation=cv2.INTER_CUBIC)

    # Conversion LAB (meilleure s√©paration luminance/couleur)
    lab = cv2.cvtColor(img_upscaled, cv2.COLOR_BGR2LAB)
    l_channel, a, b = cv2.split(lab)

    # Le texte blanc a une haute luminance -> on le garde directement
    # Seuillage pour isoler uniquement les pixels tr√®s clairs (texte)
    _, text_mask = cv2.threshold(l_channel, 150, 255, cv2.THRESH_BINARY)

    # Inversion uniquement du masque de texte
    text_black_on_white = cv2.bitwise_not(text_mask)

    # Morphologie pour nettoyer
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 2))
    text_black_on_white = cv2.morphologyEx(text_black_on_white, cv2.MORPH_CLOSE, kernel)

    return text_black_on_white


# =============================
#  OCR optimis√©
# =============================
def ocr_optimized(reader, img, method_name=""):
    """
    OCR avec param√®tres optimis√©s et affichage des r√©sultats.
    """
    results = reader.readtext(
        img,
        detail=1,
        paragraph=False,
        batch_size=1,
        min_size=5,
        text_threshold=0.4,
        low_text=0.2,
        link_threshold=0.2,
        canvas_size=4500,
        mag_ratio=3.0,
        slope_ths=0.3,
        ycenter_ths=0.7,
        height_ths=0.7,
        width_ths=0.7,
        add_margin=0.15,
        allowlist='AZERTYUIOPQSDFGHJKLMWXCVBN0123456789‚Ç¨√©√®√†√ß'
    )

    print(f"\n{'=' * 60}")
    print(f"{method_name}")
    print(f"{'=' * 60}")
    print(f"üìä {len(results)} d√©tections OCR\n")

    detected = []
    for bbox, text, conf in results:
        if conf > 0.25:
            print(f"  ‚úì '{text}' (confiance: {conf:.1%})")
            detected.append(text)
        else:
            print(f"  ‚úó '{text}' (confiance trop faible: {conf:.1%})")

    print(f"\n‚úÖ Total: {len(detected)} caract√®res valid√©s")
    return results, detected


# =============================
#  MAIN: Comparaison des m√©thodes
# =============================
if __name__ == "__main__":

    print("üîÑ Initialisation d'EasyOCR...")
    reader = easyocr.Reader(['en', 'fr'], gpu=False)
    print("‚úî EasyOCR pr√™t.\n")

    # Chargement
    img_path = r"testAZERTY2.jpg"
    img_original = cv2.imread(img_path)

    if img_original is None:
        raise FileNotFoundError(f"‚ùå Image introuvable: {img_path}")

    print(f"‚úî Image: {img_original.shape[1]}√ó{img_original.shape[0]} px\n")

    # =============================
    #  M√âTHODE 1: Inversion avec pr√©servation qualit√©
    # =============================
    img_binary_method1, img_inverted_simple = invert_with_quality_preservation(img_original)
    results1, detected1 = ocr_optimized(reader, img_binary_method1,
                                        "M√âTHODE 1: Inversion + Seuillage adaptatif")

    # =============================
    #  M√âTHODE 2: Extraction canal luminance
    # =============================
    img_method2 = extract_text_channel(img_original)
    results2, detected2 = ocr_optimized(reader, img_method2,
                                        "M√âTHODE 2: Extraction canal luminance (LAB)")

    # =============================
    #  M√âTHODE 3: Inversion simple (r√©f√©rence - mauvaise qualit√©)
    # =============================
    gray_simple = cv2.cvtColor(img_original, cv2.COLOR_BGR2GRAY)
    gray_simple = cv2.resize(gray_simple, None, fx=5, fy=5, interpolation=cv2.INTER_CUBIC)
    img_method3 = cv2.bitwise_not(gray_simple)
    results3, detected3 = ocr_optimized(reader, img_method3,
                                        "M√âTHODE 3: Inversion simple (r√©f√©rence)")

    # =============================
    #  Visualisation comparative
    # =============================
    plt.figure(figsize=(20, 10))

    # Ligne 1: Image originale + √©tapes interm√©diaires
    plt.subplot(2, 4, 1)
    plt.imshow(cv2.cvtColor(img_original, cv2.COLOR_BGR2RGB))
    plt.title("Original\n(texte blanc sur fond sombre)", fontsize=10)
    plt.axis('off')

    plt.subplot(2, 4, 2)
    plt.imshow(img_inverted_simple, cmap='gray')
    plt.title("√âtape: Inversion simple\n(avant seuillage)", fontsize=10)
    plt.axis('off')

    plt.subplot(2, 4, 3)
    plt.imshow(img_binary_method1, cmap='gray')
    plt.title(f"M√âTHODE 1: Seuillage adaptatif\n{len(detected1)} d√©tections", fontsize=10,
              color='green' if len(detected1) > len(detected3) else 'red')
    plt.axis('off')

    plt.subplot(2, 4, 4)
    plt.imshow(img_method2, cmap='gray')
    plt.title(f"M√âTHODE 2: Canal luminance\n{len(detected2)} d√©tections", fontsize=10,
              color='green' if len(detected2) > len(detected3) else 'red')
    plt.axis('off')


    # Ligne 2: R√©sultats OCR visuels
    def draw_ocr_results(img, results, title):
        img_color = cv2.cvtColor(img.copy(), cv2.COLOR_GRAY2BGR) if len(img.shape) == 2 else img.copy()
        for bbox, text, conf in results:
            if conf > 0.25:
                pts = np.array(bbox, dtype=np.int32)
                cv2.polylines(img_color, [pts], True, (0, 255, 0), 3)
                cv2.putText(img_color, f"{text}", tuple(pts[0]),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
        return img_color


    plt.subplot(2, 4, 5)
    img_result1 = draw_ocr_results(img_binary_method1, results1, "M√©thode 1")
    plt.imshow(cv2.cvtColor(img_result1, cv2.COLOR_BGR2RGB))
    plt.title(f"OCR M√©thode 1\nD√©tections: {detected1}", fontsize=9)
    plt.axis('off')

    plt.subplot(2, 4, 6)
    img_result2 = draw_ocr_results(img_method2, results2, "M√©thode 2")
    plt.imshow(cv2.cvtColor(img_result2, cv2.COLOR_BGR2RGB))
    plt.title(f"OCR M√©thode 2\nD√©tections: {detected2}", fontsize=9)
    plt.axis('off')

    plt.subplot(2, 4, 7)
    img_result3 = draw_ocr_results(img_method3, results3, "M√©thode 3")
    plt.imshow(cv2.cvtColor(img_result3, cv2.COLOR_BGR2RGB))
    plt.title(f"OCR M√©thode 3 (r√©f√©rence)\nD√©tections: {detected3}", fontsize=9)
    plt.axis('off')

    plt.subplot(2, 4, 8)
    plt.imshow(img_method3, cmap='gray')
    plt.title(f"M√âTHODE 3: Inversion simple\n{len(detected3)} d√©tections (r√©f√©rence)", fontsize=10)
    plt.axis('off')

    plt.tight_layout()
    plt.savefig('comparison_inversion_methods.png', dpi=200, bbox_inches='tight')
    plt.show()

    # =============================
    #  R√©sum√© final
    # =============================
    print(f"\n{'=' * 60}")
    print("R√âSUM√â COMPARATIF")
    print(f"{'=' * 60}")
    print(f"M√©thode 1 (seuillage adaptatif):  {len(detected1)} caract√®res")
    print(f"M√©thode 2 (canal luminance):      {len(detected2)} caract√®res")
    print(f"M√©thode 3 (inversion simple):     {len(detected3)} caract√®res")

    best = max([("M√©thode 1", len(detected1)),
                ("M√©thode 2", len(detected2)),
                ("M√©thode 3", len(detected3))],
               key=lambda x: x[1])

    print(f"\nüèÜ Meilleure m√©thode: {best[0]} ({best[1]} d√©tections)")
    print("\nüí° Conseils d'optimisation:")
    print("   - Augmenter blockSize si les caract√®res sont √©pais")
    print("   - Diminuer C si trop de bruit est conserv√©")
    print("   - Ajuster le seuil LAB (150) selon la luminosit√© de votre clavier")
