#trie
import skimage
import skimage.io
import skimage.color
import skimage.filters
import skimage.measure
import skimage.morphology
from skimage.filters import threshold_local
from matplotlib import pyplot as plt
import numpy as np
from PIL import Image
import pytesseract
from utils import sobel

pytesseract.pytesseract.tesseract_cmd = r"C:\Users\Théo\AppData\Local\Programs\Tesseract-OCR\tesseract.exe"


def detect_layout_from_image(img_paths, debug=False):
    """
    Detect keyboard layout (AZERTY / QWERTY / QWERTZ) using geometric heuristics
    on key centroids. OCR fallback if geometry is ambiguous.
    """
    results = []

    for img_path in img_paths:

        fig, axes = plt.subplots(1, 10, figsize=(32, 6))

        # ------------------------------------------------------------------
        # 1. Lecture + prétraitement
        # ------------------------------------------------------------------
        img = plt.imread(img_path)
        if img.shape[-1] == 4:
            img = img[..., :3]   # remove alpha

        if debug:
            axes[0].imshow(img)
            axes[0].set_title("1. Original")
            axes[0].axis("off")

        gray = skimage.color.rgb2gray(img)
        if debug:
            axes[1].imshow(gray, cmap="gray")
            axes[1].set_title("2. Gray")
            axes[1].axis("off")

        edges = sobel(gray)
        if debug:
            axes[2].imshow(edges, cmap="gray")
            axes[2].set_title("3. Sobel")
            axes[2].axis("off")

        # ------------------------------------------------------------------
        # 2. Binarisation adaptative + nettoyage
        # ------------------------------------------------------------------
        T = threshold_local(edges, block_size=51, offset=5)
        binary = edges > T

        binary = skimage.morphology.remove_small_objects(binary, min_size=50)
        binary = skimage.morphology.remove_small_holes(binary, area_threshold=200)

        if debug:
            axes[3].imshow(binary, cmap="gray")
            axes[3].set_title("4. Binary (Adaptive)")
            axes[3].axis("off")

        # ------------------------------------------------------------------
        # 3. Composantes connexes (labels) + filtrage par aire
        # ------------------------------------------------------------------
        labels = skimage.measure.label(binary)
        regions = skimage.measure.regionprops(labels)

        if debug:
            axes[4].imshow(labels, cmap="nipy_spectral")
            axes[4].set_title("5. Labels")
            axes[4].axis("off")

        H, W = edges.shape
        area_min = (H * W) * 0.00005   # 0.005% de l'image
        area_max = (H * W) * 0.01      # 1% de l'image

        key_regions = [r for r in regions if area_min < r.area < area_max]

        if debug:
            # On colorie uniquement les régions sélectionnées
            mask_keys = np.zeros_like(labels)
            for i, r in enumerate(key_regions, start=1):
                mask_keys[labels == r.label] = i
            axes[5].imshow(mask_keys, cmap="nipy_spectral")
            axes[5].set_title(f"6. Key Regions ({len(key_regions)})")
            axes[5].axis("off")

        if len(key_regions) < 20:
            # trop peu de touches fiables → OCR direct
            results.append(describe_unknown_keyboard([img_path])[0])
            if debug:
                axes[9].text(0.1, 0.5, "Pas assez de touches → OCR", fontsize=12)
                axes[9].axis("off")
                plt.tight_layout(); plt.show()
            continue

        # ------------------------------------------------------------------
        # 4. Extraction des centroïdes + hauteur des touches
        # ------------------------------------------------------------------
        centroids = []
        heights = []
        for r in key_regions:
            cy, cx = r.centroid
            minr, minc, maxr, maxc = r.bbox
            h = maxr - minr
            centroids.append([cy, cx])
            heights.append(h)

        centroids = np.array(centroids)
        heights = np.array(heights)
        median_h = np.median(heights)
        row_tol = median_h * 0.7  # tolérance pour le regroupement vertical

        if debug:
            axes[6].imshow(labels, cmap="nipy_spectral")
            for c in centroids:
                axes[6].plot(c[1], c[0], "ro", markersize=3)
            axes[6].set_title("7. Centroids")
            axes[6].axis("off")

        # ------------------------------------------------------------------
        # 5. Regroupement en rangées par Y
        # ------------------------------------------------------------------
        # On trie d'abord par Y (haut → bas)
        order = np.argsort(centroids[:, 0])
        centroids_sorted = centroids[order]

        rows = []
        current_row = [centroids_sorted[0]]
        current_y = centroids_sorted[0][0]

        for c in centroids_sorted[1:]:
            if abs(c[0] - current_y) <= row_tol:
                current_row.append(c)
                current_y = (current_y * (len(current_row) - 1) + c[0]) / len(current_row)
            else:
                rows.append(np.array(current_row))
                current_row = [c]
                current_y = c[0]
        rows.append(np.array(current_row))

        # On trie chaque rangée par X (gauche → droite)
        rows = [row[np.argsort(row[:, 1])] for row in rows]

        # On supprime les rangées minuscules
        rows = [row for row in rows if len(row) >= 5]

        if len(rows) < 2:
            results.append(describe_unknown_keyboard([img_path])[0])
            if debug:
                axes[9].text(0.1, 0.5, "Pas assez de rangées → OCR", fontsize=12)
                axes[9].axis("off")
                plt.tight_layout(); plt.show()
            continue

        # ------------------------------------------------------------------
        # 6. Choisir la rangée "lettres"
        #    → on prend la rangée avec le plus de touches parmi les rangées
        #      qui ne sont pas la toute première (souvent la ligne des chiffres)
        # ------------------------------------------------------------------
        # On ordonne les rangées du haut vers le bas (déjà fait) :
        # row[0] ~ chiffres, row[1] ~ lettres, etc.
        candidate_rows = rows[1:] if len(rows) > 2 else rows
        letters_row = max(candidate_rows, key=lambda r: len(r))

        if debug:
            # On affiche la rangée sélectionnée
            axes[7].imshow(labels, cmap="nipy_spectral")
            for c in letters_row:
                axes[7].plot(c[1], c[0], "yo", markersize=5)
            axes[7].set_title(f"8. Letters row (len={len(letters_row)})")
            axes[7].axis("off")

        # ------------------------------------------------------------------
        # 7. Analyse des espacements sur la rangée de lettres
        # ------------------------------------------------------------------
        xs = letters_row[:, 1]
        diffs = np.diff(xs)

        if len(diffs) < 3:
            # Rangée trop courte pour une analyse fiable → OCR
            results.append(describe_unknown_keyboard([img_path])[0])
            if debug:
                axes[9].text(0.1, 0.5, "Row trop courte → OCR", fontsize=12)
                axes[9].axis("off")
                plt.tight_layout(); plt.show()
            continue

        mean_gap = np.mean(diffs)
        d_norm = diffs / mean_gap
        var_norm = np.var(d_norm)

        # on regarde quelques positions clés
        first_gap = d_norm[0]
        mid_index = len(d_norm) // 2
        mid_gap = d_norm[mid_index] if len(d_norm) > 4 else None

        if debug:
            axes[8].plot(d_norm, marker="o")
            axes[8].axhline(1.0, linestyle="--")
            axes[8].set_title("9. Normalized gaps")
            axes[8].set_xlabel("index")
            axes[8].set_ylabel("gap / mean_gap")
            axes[8].grid(True)

        # ------------------------------------------------------------------
        # 8. Scoring pour QWERTY / AZERTY / QWERTZ
        # ------------------------------------------------------------------
        score_qwerty = 0
        score_azerty = 0
        score_qwertz = 0

        # QWERTY : gaps très réguliers
        if var_norm < 0.05:
            score_qwerty += 2
        if abs(first_gap - 1.0) < 0.15:
            score_qwerty += 1

        # AZERTY : premier gap anormalement grand (ou petit), plus de variance
        if first_gap > 1.25 or first_gap < 0.75:
            score_azerty += 2
        if var_norm > 0.05:
            score_azerty += 1

        # QWERTZ : gap anormal au milieu (Y/Z déplacés)
        if mid_gap is not None and mid_gap > 1.25:
            score_qwertz += 2
        if var_norm < 0.15:
            score_qwertz += 1

        scores = {
            "QWERTY": score_qwerty,
            "AZERTY": score_azerty,
            "QWERTZ": score_qwertz
        }
        best_layout = max(scores, key=scores.get)
        best_score = scores[best_layout]

        if debug:
            axes[9].text(
                0.05, 0.4,
                f"Scores:\nQWERTY={score_qwerty}\nAZERTY={score_azerty}\nQWERTZ={score_qwertz}\n\n"
                f"Chosen: {best_layout if best_score > 1 else 'OCR fallback'}",
                fontsize=12
            )
            axes[9].axis("off")
            plt.tight_layout()
            plt.show()

        # Si le score est trop faible → OCR fallback
        if best_score <= 1:
            layout = describe_unknown_keyboard([img_path])[0]
        else:
            layout = best_layout

        results.append(layout)

    return results




# -------------------------------------------------------------
# OCR fallback
# -------------------------------------------------------------
def describe_unknown_keyboard(img_paths):

    patterns = {
        'QWERTY': "QWERTYUIOP",
        'AZERTY': "AZERTYUIOP",
        'QWERTZ': "QWERTZUIOP",
        'DVORAK': "AOEUIDHTNS",
        'COLEMAK': "QWFPGJLUY"
    }

    results = []

    for img_path in img_paths:

        img = Image.open(img_path).convert("L")

        img_bin = img.point(lambda x: 0 if x < 120 else 255, "1")

        raw_text = pytesseract.image_to_string(
            img_bin,
            config="--psm 6 --oem 3 -c tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        )

        text = "".join([c for c in raw_text.upper() if c.isalpha()])

        print("OCR full image:", text)

        if len(text) < 3:
            results.append("Unknown")
            continue

        best_layout = "Unknown"
        best_score = -1

        for layout, pattern in patterns.items():
            score = sum(c in text for c in pattern)
            if score > best_score:
                best_score = score
                best_layout = layout

        results.append(best_layout)

    return results
