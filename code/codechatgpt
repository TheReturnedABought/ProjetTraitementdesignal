import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter, convolve
from skimage.measure import label, regionprops
from skimage.morphology import remove_small_objects
from skimage.filters import threshold_otsu
from skimage.color import rgb2gray


# ================================================================
#      1. Détection des touches + regroupement en rangées
# ================================================================
def detect_keys_and_rows(img_path):

    img = plt.imread(img_path)

    if img.ndim == 3:
        gray = rgb2gray(img)
    else:
        gray = img

    gray_blur = gaussian_filter(gray, sigma=1.0)

    scharr_x = np.array([
        [-3, 0, 3],
        [-10, 0, 10],
        [-3, 0, 3]
    ])

    scharr_y = np.array([
        [-3, -10, -3],
        [0, 0, 0],
        [3, 10, 3]
    ])

    gx = convolve(gray_blur, scharr_x)
    gy = convolve(gray_blur, scharr_y)
    mag = np.sqrt(gx**2 + gy**2)

    # Seuillage
    t = threshold_otsu(mag)
    edges = mag > t

    edges = remove_small_objects(edges, min_size=80)

    labels = label(edges)
    regions = regionprops(labels)

    key_boxes = []
    for r in regions:
        minr, minc, maxr, maxc = r.bbox
        h = maxr - minr
        w = maxc - minc
        if 20 < h < 150 and 20 < w < 150:
            key_boxes.append((minr, minc, maxr, maxc))

    if len(key_boxes) < 20:
        print("⚠ Pas assez de touches détectées. Abandon.")
        return img, []

    # ==========================================================
    # Regroupement en rangées
    # ==========================================================
    centroids = []
    for (minr, minc, maxr, maxc) in key_boxes:
        cy = (minr + maxr) / 2
        cx = (minc + maxc) / 2
        centroids.append([cy, cx])

    centroids = np.array(centroids)

    # Trier par Y
    order = np.argsort(centroids[:, 0])
    centroids = centroids[order]
    key_boxes = [key_boxes[i] for i in order]

    rows = []
    current_row = [centroids[0]]
    current_boxes = [key_boxes[0]]

    row_tol = np.median(np.diff(np.sort(centroids[:, 0]))) * 1.5
    if np.isnan(row_tol) or row_tol == 0:
        row_tol = 25  # fallback safe

    for i in range(1, len(centroids)):
        if abs(centroids[i][0] - current_row[-1][0]) < row_tol:
            current_row.append(centroids[i])
            current_boxes.append(key_boxes[i])
        else:
            rows.append((np.array(current_row), current_boxes))
            current_row = [centroids[i]]
            current_boxes = [key_boxes[i]]

    rows.append((np.array(current_row), current_boxes))

    # Trier horizontalement chaque rangée
    final_rows = []
    for cent, boxes in rows:
        if len(cent) < 3:
            continue  # ignore rangées trop petites
        idx = np.argsort(cent[:, 1])
        final_rows.append((cent[idx], [boxes[i] for i in idx]))

    return img, final_rows



# ================================================================
#      2. CLASSIFICATION ROBUSTE SANS OCR
# ================================================================
def classify_layout(rows):
    if len(rows) == 0:
        return "Unknown"

    # Choisir la rangée la plus longue → rangée des lettres
    letters_row = max(rows, key=lambda r: len(r[0]))[0]

    if len(letters_row) < 5:
        return "Unknown"

    xs = np.sort(letters_row[:, 1])

    # éviter division par 0
    span = xs[-1] - xs[0]
    if span == 0:
        return "Unknown"

    x_norm = (xs - xs[0]) / span

    gaps = np.diff(x_norm)

    if len(gaps) == 0:
        return "Unknown"

    mean_gap = np.mean(gaps)

    # =============================
    # Classification robuste
    # =============================

    # 1) QWERTZ = gros trou à la fin
    if gaps[-1] > mean_gap * 1.7:
        return "QWERTZ"

    # 2) AZERTY = gros gap entre première et deuxième touche
    if gaps[0] > mean_gap * 1.35:
        return "AZERTY"

    # 3) QWERTY sinon
    return "QWERTY"



# ================================================================
#               3. PIPELINE + AFFICHAGE
# ================================================================
def process_keyboard(img_path):

    img, rows = detect_keys_and_rows(img_path)

    layout = classify_layout(rows)
    print("\n>>> CLAVIER DETECTE :", layout)

    if len(rows) == 0:
        return layout

    colors = ['red', 'green', 'blue', 'yellow', 'cyan', 'magenta']

    plt.figure(figsize=(14, 6))
    plt.imshow(rgb2gray(img), cmap="gray")

    for i, (cent, boxes) in enumerate(rows):
        for (minr, minc, maxr, maxc) in boxes:
            plt.gca().add_patch(plt.Rectangle(
                (minc, minr),
                maxc - minc, maxr - minr,
                edgecolor=colors[i % len(colors)],
                linewidth=2, fill=False
            ))

    plt.title("Touches regroupées – Clavier détecté : " + layout)
    plt.axis('off')
    plt.show()

    return layout



# ================================================================
# LANCEMENT
# ================================================================
process_keyboard("../data/AZERTY3.jpg")
